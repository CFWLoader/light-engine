# 基础着色流程

- [Open-GL教学源码地址](https://github.com/opengl-tutorials/ogl)

[Open-GL教程8](http://www.opengl-tutorial.org/cn/beginners-tutorials/tutorial-8-basic-shading/)中介绍`基本着色`算法，由于假定读者已经较为熟悉Open-GL的一些操作，并且该部分着重修改`Shader`部分的源码而未在教程中表现出来，需要消耗一些时间去理解内容。

首先，直接贴上附个人注释的`顶点shader代码`：

``` glsl
#version 330 core

// 不要给长长的变量名吓到
// 三组数据，顶点、uv以及顶点向量
layout(location = 0) in vec3 vertexPosition_modelspace;
layout(location = 1) in vec2 vertexUV;
layout(location = 2) in vec3 vertexNormal_modelspace;

// 这里的数据会送到片元着色器
out vec2 UV;
// 世界坐标下的顶点坐标
out vec3 Position_worldspace;
// 摄像机空间下的向量
out vec3 Normal_cameraspace;
// 摄像机(0,0,0)下的视线向量
out vec3 EyeDirection_cameraspace;
// 摄像机空间下的光线向量
out vec3 LightDirection_cameraspace;

// 整个MVP矩阵
uniform mat4 MVP;
// 转换到摄像机空间的view矩阵
uniform mat4 V;
// 转换到全局坐标的Model矩阵
uniform mat4 M;
// 世界坐标系下的点光源坐标
uniform vec3 LightPosition_worldspace;

void main(){

	// 标准的局部坐标MVP转换到最终摄像机下投影坐标
	gl_Position =  MVP * vec4(vertexPosition_modelspace,1);
	
	// 通过M矩阵计算出世界坐标
	Position_worldspace = (M * vec4(vertexPosition_modelspace,1)).xyz;
	
	// 摄像机空间下，顶点到摄像机(0,0,0)的向量，得出视线向量
	vec3 vertexPosition_cameraspace = ( V * M * vec4(vertexPosition_modelspace,1)).xyz;
	EyeDirection_cameraspace = vec3(0,0,0) - vertexPosition_cameraspace;

	// 计算摄像机空间下顶点到光线的向量，这里没有从局部到世界的转换，直接使用点光源坐标作为世界坐标
	vec3 LightPosition_cameraspace = ( V * vec4(LightPosition_worldspace,1)).xyz;
    // 光线到顶点的向量=光源向量(这里直接将光源坐标当作视线原点到光源的向量)+顶点到摄像机的向量
    // 画个图，用高中的向量知识就能理解
	LightDirection_cameraspace = LightPosition_cameraspace + EyeDirection_cameraspace;
	
	// 转换到摄像机空间下的顶点法线向量
    // 目前只能正确计算出Model矩阵缩放为1的法线
	Normal_cameraspace = ( V * M * vec4(vertexNormal_modelspace,0)).xyz;
	
	// 常规的UV数据输出
	UV = vertexUV;
}
```

整个顶点着色器主要的逻辑是先将`片元着色器`所需的各类向量和转换好的坐标计算完毕，最终顶点颜色的计算就在`片元着色器`中完成。